<!doctype html>
<html lang="en">
<head>
<link rel="icon" type="image/png" href="bnb-favicon.png?">
<meta charset="utf-8" />
<title>BuildNBlocks</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
body,html{margin:0;padding:0;overflow:hidden;background:#222;cursor:default;}
#toolbar{position:fixed;bottom:0;left:50%;transform:translateX(-50%);display:flex;gap:10px;padding:8px 12px;background:rgba(0,0,0,0.5);border-radius:6px;font-family:sans-serif;color:#fff;z-index:5;}
.tool{padding:6px 12px;border:1px solid #fff;border-radius:4px;cursor:pointer;user-select:none;}
.tool.active{background:#4cc3ff;color:#777;}
#status{position:fixed;top:8px;left:8px;padding:6px 10px;background:rgba(0,0,0,0.5);color:#fff;font:13px/1.2 system-ui,sans-serif;border-radius:6px;z-index:5;}
#nameInput{position:fixed;top:8px;right:8px;z-index:5;padding:4px;}
#playerList{position:fixed;top:50px;right:8px;padding:6px 10px;background:rgba(0,0,0,0.5);color:#fff;font:13px/1.2 system-ui,sans-serif;border-radius:6px;z-index:5;}
#healthContainer {
  position: fixed;
  bottom: 20px;
  left: 20px;
  width: 200px;
  height: 20px;
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid #fff;
  border-radius: 4px;
  overflow: hidden;
  z-index: 5;
}

#healthBar {
  width: 100%;
  height: 100%;
  background: #4cc3ff;
  transition: width 0.2s ease;
}
/* Center-top toolbar */
#saveLoadContainer {
  position: fixed;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
  display: flex;
  gap: 8px;
}

/* Buttons look consistent */
#saveLoadContainer button {
  background: #ffffffcc;
  border: 1px solid #999;
  border-radius: 4px;
  padding: 6px 12px;
  font-size: 14px;
  cursor: pointer;
  font-family: sans-serif;
}

#saveLoadContainer button:hover {
  background: #fff;
}

.joystick {
  position: absolute;
  width: 120px;
  height: 120px;
  background: rgba(200, 200, 200, 0.2);
  border-radius: 50%;
  touch-action: none;
}
.stick {
  width: 60px;
  height: 60px;
  background: rgba(255, 255, 255, 0.6);
  border-radius: 50%;
  position: absolute;
  top: 30px;
  left: 30px;
  pointer-events: none;
}
#jump-btn {
  position: absolute;
  bottom: 80px;
  right: 40px;
  width: 80px;
  height: 80px;
  background: rgba(255, 255, 255, 0.7);
  border-radius: 50%;
  font-size: 20px;
  border: none;
  touch-action: none;
}
</style>
</head>
<body>

<div id="mobile-ui" style="display:none;">
  <!-- Movement joystick (left) -->
  <div id="joystick-left" class="joystick" style="bottom:40px; left:40px;">
    <div class="stick"></div>
  </div>

  <!-- Camera joystick (right) -->
  <div id="joystick-right" class="joystick" style="bottom:40px; right:40px;">
    <div class="stick"></div>
  </div>

  <!-- Jump button -->
  <button id="jump-btn">â¤’</button>
</div>
<div id="chat" style="position:absolute; bottom:750px; left:10px; width:300px; background:rgba(0,0,0,0.5); padding:5px; font-family:sans-serif; font-size:14px; color:white;">
  <div id="chat-messages" style="height:150px; overflow-y:auto; margin-bottom:5px;"></div>
  <input id="chat-input" type="text" placeholder="Type a message..." style="width:100%; box-sizing:border-box;">
</div>
<div id="toolbar">
  <div class="tool" id="tool-build">Build (1)</div>
  <div class="tool" id="tool-remove">Remove (2)</div>
</div>
<!-- Save / Load UI -->
<div id="saveLoadContainer">
  <button id="saveBtn">ðŸ’¾ Save</button>
  <button id="loadBtn">ðŸ“‚ Load</button>
  <input type="file" id="fileInput" style="display:none" accept=".json">
</div>
<div id="status">offline</div>
<input id="nameInput" placeholder="Your name"/>
<div id="playerList">Players:</div>
<div id="healthContainer">
  <div id="healthBar"></div>
</div>
<input type="color" id="blockColor" value="ffffff" placeholder="#hex" 
  style="position:fixed;bottom:8px;right:8px;width:70px;padding:4px;border-radius:4px;border:none;font-family:sans-serif;z-index:5;">


<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="/socket.io/socket.io.js"></script>

<script>

// --- Cookie Helpers ---
function setCookie(name, value, days = 365) {
    const d = new Date();
    d.setTime(d.getTime() + (days*24*60*60*1000));
    document.cookie = name + "=" + encodeURIComponent(value) + ";expires=" + d.toUTCString() + ";path=/";
}

function getCookie(name) {
    const value = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
    return value ? decodeURIComponent(value.pop()) : null;
}

/* ---------- THREE.JS SETUP ---------- */
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x88ccff);
const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,0.1,200);
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);
scene.add(new THREE.HemisphereLight(0xffffff,0x444444,0.8));
const sun=new THREE.DirectionalLight(0xffffff,0.8);
sun.position.set(5,10,5);
scene.add(sun);

const textureLoader=new THREE.TextureLoader();
const studTexture=textureLoader.load('stud.png',t=>{t.wrapS=t.wrapT=THREE.RepeatWrapping;t.repeat.set(2,2);});

function getBlockColor() {
  const hexInput = document.getElementById('blockColor')
  if(!hexInput) return 0xffffff
  const hex = hexInput.value || '#ffffff'
  return parseInt(hex.replace('#',''), 16) || 0xffffff
}

if (/Mobi|Android/i.test(navigator.userAgent)) {
  document.getElementById("mobile-ui").style.display = "block";

  function setupJoystick(joystick, callback) {
    const stick = joystick.querySelector(".stick");
    const rect = joystick.getBoundingClientRect();
    const center = { x: rect.width/2, y: rect.height/2 };
    let active = false;

    function update(e) {
      if (!active) return;
      const touch = e.touches[0];
      const dx = touch.clientX - rect.left - center.x;
      const dy = touch.clientY - rect.top - center.y;
      const dist = Math.min(Math.hypot(dx, dy), rect.width/2 - 20);
      const angle = Math.atan2(dy, dx);
      const x = Math.cos(angle) * dist;
      const y = Math.sin(angle) * dist;
      stick.style.transform = `translate(${x}px, ${y}px)`;
      callback(x/(rect.width/2), y/(rect.height/2));
    }

    joystick.addEventListener("touchstart", e => {
      active = true;
      update(e);
    });
    joystick.addEventListener("touchmove", update);
    joystick.addEventListener("touchend", () => {
      active = false;
      stick.style.transform = "translate(0,0)";
      callback(0,0);
    });
  }

  // Movement joystick â†’ set movement vector
  let joyMove = {x:0, y:0};
  setupJoystick(document.getElementById("joystick-left"), (x,y) => {
    joyMove.x = x; joyMove.y = y;
  });

  // Camera joystick â†’ change yaw/pitch
  let joyCam = {x:0, y:0};
  setupJoystick(document.getElementById("joystick-right"), (x,y) => {
    joyCam.x = x; joyCam.y = y;
  });

  // Jump button
  const jumpBtn = document.getElementById("jump-btn");
  jumpBtn.addEventListener("touchstart", e => { e.preventDefault(); keys['Space'] = true; });
  jumpBtn.addEventListener("touchend", e => { e.preventDefault(); keys['Space'] = false; });

  // Hook into your step loop
  const oldStep = step;
  step = function(dt) {
    // Movement override for mobile
    if (/Mobi|Android/i.test(navigator.userAgent)) {
      let forward = new THREE.Vector3(-Math.sin(local.cam.yaw), 0, -Math.cos(local.cam.yaw));
      let right = new THREE.Vector3(Math.cos(local.cam.yaw), 0, -Math.sin(local.cam.yaw));
      let move = new THREE.Vector3();
      move.addScaledVector(forward, -joyMove.y);
      move.addScaledVector(right, joyMove.x);
      if (move.length() > 0) {
        move.normalize().multiplyScalar(5 * dt);
        local.pos.add(new THREE.Vector3(move.x, 0, move.z));
      }
      // Camera control
      local.cam.yaw += joyCam.x * dt * 2.5;
      local.cam.pitch -= joyCam.y * dt * 2.5;
    }
    oldStep(dt);
  };
}
  
/* ---------- BLOCKS ---------- */
const blocks=[], blockIndex=new Map(), indestructibleBlocks=new Set();
function keyOf(x,y,z){return `${x}|${y}|${z}`;}
function makeBlock(x, y, z, indestructible = false, color) {
  const k = keyOf(x, y, z);
  if (blockIndex.has(k)) return;

  if (color === undefined) color = getBlockColor();

  const material = new THREE.MeshStandardMaterial({
    map: studTexture,
    color: color
  });

  const b = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), material);
  b.position.set(x + 0.5, y + 0.5, z + 0.5);

  // store grid coords and flags on the mesh
  b.userData.grid = { x, y, z };
  b.userData.indestructible = !!indestructible;

  scene.add(b);
  blocks.push(b);
  blockIndex.set(k, b);

  if (indestructible) indestructibleBlocks.add(b);
  return b;
}
function removeBlockAt(x,y,z){
  const k = keyOf(x,y,z), m = blockIndex.get(k);
  if (!m || indestructibleBlocks.has(m)) return false;
  scene.remove(m); blocks.splice(blocks.indexOf(m),1); blockIndex.delete(k); return true;
}

// ---------- BUILD PREVIEW BLOCK ----------
const previewMaterial = new THREE.MeshStandardMaterial({color: 0x00ff00, transparent: true, opacity: 0.5});
const previewGeometry = new THREE.BoxGeometry(1,1,1);
const previewBlock = new THREE.Mesh(previewGeometry, previewMaterial);
previewBlock.visible = false; // hidden until needed
scene.add(previewBlock);


/* ---------- AVATAR ---------- */
function makeAvatar(colorTorso=0x4cc3ff,colorLeg=0x3333ff){
  const g=new THREE.Group();
  const torso=new THREE.Mesh(new THREE.BoxGeometry(1,0.9,0.5),new THREE.MeshStandardMaterial({color:colorTorso})); torso.position.y=0.4; g.add(torso);
  const head=new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.8),new THREE.MeshStandardMaterial({color:0xffe08a})); head.position.y=1.25; g.add(head);
  const shoulderL=new THREE.Group(); shoulderL.position.set(-0.65,1.1,0);
  const armL=new THREE.Mesh(new THREE.BoxGeometry(0.4,0.9,0.4),new THREE.MeshStandardMaterial({color:colorTorso})); armL.position.y=-0.7; shoulderL.add(armL); g.add(shoulderL);
  const shoulderR=new THREE.Group(); shoulderR.position.set(0.65,1.1,0);
  const armR=new THREE.Mesh(new THREE.BoxGeometry(0.4,0.9,0.4),new THREE.MeshStandardMaterial({color:colorTorso})); armR.position.y=-0.7; shoulderR.add(armR); g.add(shoulderR);
  const hipL=new THREE.Group(); hipL.position.set(-0.25,0,0);
  const legL=new THREE.Mesh(new THREE.BoxGeometry(0.4,1,0.4),new THREE.MeshStandardMaterial({color:colorLeg})); legL.position.y=-0.5; hipL.add(legL); g.add(hipL);
  const hipR=new THREE.Group(); hipR.position.set(0.25,0,0);
  const legR=new THREE.Mesh(new THREE.BoxGeometry(0.4,1,0.4),new THREE.MeshStandardMaterial({color:colorLeg})); legR.position.y=-0.5; hipR.add(legR); g.add(hipR);
  return {group:g,parts:{shoulderL,shoulderR,hipL,hipR}};
}

/* ---------- LOCAL PLAYER ---------- */
const local={id:null,colorTorso:0x4cc3ff,colorLeg:0x3333ff,pos:new THREE.Vector3(0,5,0),vel:new THREE.Vector3(),onGround:false,yaw:0,walkTime:0,cam:{yaw:0,pitch:0,dist:6},mesh:null,name:"Player"};
const {group,parts}=makeAvatar(local.colorTorso,local.colorLeg);
local.mesh={group,...parts};
scene.add(group);
local.health = 100; // max 100

/* ---------- INPUT ---------- */
const keys={}; window.addEventListener('keydown',e=>keys[e.code]=true); window.addEventListener('keyup',e=>keys[e.code]=false);
let rotating=false;
window.addEventListener('contextmenu',e=>e.preventDefault());
window.addEventListener('mousedown',e=>{ if(e.button===2){rotating=true;document.body.style.cursor='none'; if(renderer.domElement.requestPointerLock) renderer.domElement.requestPointerLock();} });
window.addEventListener('mouseup',e=>{ if(e.button===2){rotating=false;document.body.style.cursor='default'; if(document.exitPointerLock) document.exitPointerLock();} });
window.addEventListener('wheel', (e) => {
    local.cam.dist += e.deltaY * 0.01; // scroll sensitivity
    local.cam.dist = Math.max(2, Math.min(15, local.cam.dist)); // clamp distance
});
document.addEventListener('mousemove', e => {
  if(rotating){ 
    local.cam.yaw -= e.movementX*0.005;
    local.cam.pitch += e.movementY*0.005;
    local.cam.pitch = Math.max(-1.2, Math.min(1.2, local.cam.pitch));
  }

  // Always track mouse for build preview
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
});


/* ---------- TOOLS ---------- */
let activeTool=null;
const toolBuild=document.getElementById('tool-build'), toolRemove=document.getElementById('tool-remove');
function setTool(tool){ activeTool=(activeTool===tool)? null:tool; toolBuild.classList.toggle('active',activeTool==='build'); toolRemove.classList.toggle('active',activeTool==='remove'); }
toolBuild.onclick=()=>setTool('build'); toolRemove.onclick=()=>setTool('remove');
window.addEventListener('keydown',e=>{ if(e.code==='Digit1') setTool('build'); if(e.code==='Digit2') setTool('remove'); });
const raycaster=new THREE.Raycaster(), mouse=new THREE.Vector2();
window.addEventListener('pointerdown',e=>{
  if(e.button!==0||!activeTool)return;
  mouse.x=(e.clientX/window.innerWidth)*2-1; mouse.y=-(e.clientY/window.innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera); const hits=raycaster.intersectObjects(blocks);
  if(hits.length>0){const hit=hits[0]; const pos=hit.point.clone().add(hit.face.normal.clone().multiplyScalar(0.5));
  const x=Math.floor(pos.x),y=Math.floor(pos.y),z=Math.floor(pos.z);
  if(activeTool==='build') {
    if(!blockIndex.has(keyOf(x,y,z))){
      const color = getBlockColor()
      makeBlock(x, y, z, false, color)
      socket.emit('build', {x, y, z, color})
    }
  }
  // Your remove click path should keep this guard:
  else if (activeTool === 'remove') {
    const bx = Math.floor(hit.object.position.x - 0.5);
    const by = Math.floor(hit.object.position.y - 0.5);
    const bz = Math.floor(hit.object.position.z - 0.5);
    if (removeBlockAt(bx, by, bz)) socket.emit('remove', { x: bx, y: by, z: bz });
  }
}});

/* ---------- SOCKET.IO ---------- */
const socket=io(), statusEl=document.getElementById('status'), nameInput=document.getElementById('nameInput'), playerList=document.getElementById('playerList');
nameInput.value=local.name;
// Load name from cookie if exists
const savedName = getCookie('playerName');
if(savedName) {
    local.name = savedName;
    nameInput.value = savedName;
}

// Listen for name changes
nameInput.addEventListener('change', () => {
    local.name = nameInput.value;
    setCookie('playerName', local.name);  // save to cookie
    socket.emit('name-change', {name: local.name});
});

const others=new Map();
function makeNametagSprite(text){
  const canvas=document.createElement('canvas'); canvas.width=256; canvas.height=64;
  const ctx=canvas.getContext('2d'); ctx.font='28px sans-serif'; ctx.fillStyle='white'; ctx.textAlign='center'; ctx.fillText(text,128,48);
  const tex=new THREE.CanvasTexture(canvas); tex.needsUpdate=true;
  const mat=new THREE.SpriteMaterial({map:tex,transparent:true});
  const sprite=new THREE.Sprite(mat); sprite.scale.set(2,0.5,1); return {sprite,canvas,ctx,texture:tex};
}

const chatMessages = document.getElementById("chat-messages");
const chatInput = document.getElementById("chat-input");

chatInput.addEventListener("keydown", e => {
  if (e.key === "Enter" && chatInput.value.trim() !== "") {
    socket.emit("chat", { name: local.name, text: chatInput.value.trim() });
    chatInput.value = "";
  }
});

socket.on("chat", data => {
  const div = document.createElement("div");
  div.textContent = data.name + ": " + data.text;
  chatMessages.appendChild(div);
  chatMessages.scrollTop = chatMessages.scrollHeight;
});

function spawnOther(id,p){
  if(others.has(id))return;
  const {group,parts}=makeAvatar(0xff4444,0x3333ff);
  group.position.set(p.x,p.y - 0.25,p.z);
  const nametagObj=makeNametagSprite(p.name||"Player");
  nametagObj.sprite.position.set(0,2.1,0); group.add(nametagObj.sprite);
  scene.add(group);
  others.set(id,{group,...parts,nametag:nametagObj,pos:new THREE.Vector3(p.x,p.y - 0.25,p.z),walkTime:0,name:p.name||"Player"});
  updatePlayerList();
}
function removeOther(id){ const p=others.get(id); if(!p)return; scene.remove(p.group); others.delete(id); updatePlayerList();}
function updatePlayerList(){
  let html=`Players:<br>${local.name} (You)<br>`;
  others.forEach(p=>html+=p.name+'<br>'); playerList.innerHTML=html;
}
socket.on('connect', () => {
    local.id = socket.id;
    statusEl.textContent = `online â€¢ ${local.name}`;
    updatePlayerList();

    // Send initial join info
    socket.emit('join', {
        x: local.pos.x,
        y: local.pos.y - 1,
        z: local.pos.z,
        yaw: local.yaw,
        name: local.name
    });
});

socket.on('init', payload => {
    for (const b of payload.blocks) {
        makeBlock(b.x, b.y, b.z, !!b.indestructible, b.color);
    }

    // Spawn existing players
    for (const [id, p] of Object.entries(payload.players)) {
        if (id !== local.id) spawnOther(id, p);
    }
});

socket.on('player-join',({id,x,y,z,name})=>{ if(id!==local.id) spawnOther(id,{x,y,z,name}); });
socket.on('player-leave',({id})=>removeOther(id));
socket.on('player-update',({id,x,y,z,yaw,name})=>{
  if(id===local.id){ if(name) local.name=name; return; }
  const p=others.get(id); if(!p) return;
  if(x!==undefined)p.pos.x=x; if(y!==undefined)p.pos.y=y - 0.25; if(z!==undefined)p.pos.z=z;
  if(yaw!==undefined)p.group.rotation.y=yaw;
  if(name!==undefined){ p.name=name; const ctx=p.nametag.ctx; ctx.clearRect(0,0,256,64); ctx.fillText(name,128,48); p.nametag.texture.needsUpdate=true; }
  updatePlayerList();
});

// Server replaced the world: clear (except weâ€™ll reconstruct ground from the packet)
socket.on('world-set', ({ blocks: worldBlocks }) => {
  // remove all existing meshes
  blocks.forEach(m => scene.remove(m));
  blocks.length = 0;
  blockIndex.clear();
  indestructibleBlocks.clear();

  // rebuild from snapshot
  for (const b of worldBlocks) {
    makeBlock(b.x, b.y, b.z, !!b.indestructible, b.color);
  }
});

/* ---------- BUILD/REMOVE LISTEN ---------- */
socket.on('build', ({x,y,z,color}) => {
  makeBlock(x,y,z,false,color)
})
socket.on('remove',({x,y,z})=>{ removeBlockAt(x,y,z); });

// --- SAVE (authoritative) ---
// when you click "Save", ask the server for the current world, then download it
document.getElementById("saveBtn").addEventListener("click", () => {
  socket.emit('request-save');
});

// server sends world snapshot
socket.on('world-data', ({ blocks: worldBlocks }) => {
  // Optional: skip ground in the save file, so users only save their custom builds
  const data = worldBlocks
    .filter(b => !b.indestructible) // donâ€™t save the platform
    .map(b => ({
      // store integer grid coords; the server expects these on load
      x: b.x,
      y: b.y,
      z: b.z,
      color: b.color
    }));

  const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = "buildnblocks_save.json";
  a.click();
  URL.revokeObjectURL(url);
});

// --- LOAD (authoritative) ---
// show file picker
document.getElementById("loadBtn").addEventListener("click", () => {
  document.getElementById("fileInput").click();
});

document.getElementById("fileInput").addEventListener("change", event => {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = e => {
    let data;
    try {
      data = JSON.parse(e.target.result);
    } catch {
      alert('Invalid file format.');
      return;
    }
    if (!Array.isArray(data)) {
      alert('Invalid world data.');
      return;
    }

    // We send grid coords + color to server; server will rebuild and broadcast
    const payload = {
      blocks: data.map(b => ({
        x: Math.round(b.x),
        y: Math.round(b.y),
        z: Math.round(b.z),
        color: (typeof b.color === 'number' && b.color >= 0 && b.color <= 0xffffff) ? b.color : 0xffffff
      }))
    };
    socket.emit('load-world', payload);
  };
  reader.readAsText(file);
});

/* ---------- PHYSICS & ANIMATION ---------- */
function step(dt) {
    const forward = new THREE.Vector3(-Math.sin(local.cam.yaw), 0, -Math.cos(local.cam.yaw));
    const right = new THREE.Vector3(Math.cos(local.cam.yaw), 0, -Math.sin(local.cam.yaw));

    // Movement input
    let move = new THREE.Vector3();
    if (keys['KeyW']) move.add(forward);
    if (keys['KeyS']) move.sub(forward);
    if (keys['KeyA']) move.sub(right);
    if (keys['KeyD']) move.add(right);

    if (move.length() > 0) {
      move.normalize();
      let speed = 5;
      if (keys['ShiftLeft'] || keys['ShiftRight']) speed *= 1.5; // faster when Shift
      move.multiplyScalar(speed * dt);
    }

    // Apply horizontal movement first
    local.pos.add(new THREE.Vector3(move.x, 0, move.z));

    // Gravity
    local.vel.y += -20 * dt;
    local.pos.y += local.vel.y * dt;

    // --- Killfloor ---
    const killHeight = -10;
    if (local.pos.y < killHeight) {
        local.health = 0;
    }

    if (local.health <= 0) {
        local.pos.set(0, 2.5, 0);
        local.vel.set(0, 0, 0);
        local.health = 100;
    }

    // --- COLLISIONS (fixed) ---
    const radius = 0.5;
    const playerHeight = 2.5;
    const halfHeight = playerHeight / 2;

    const playerMin = new THREE.Vector3(
        local.pos.x - radius,
        local.pos.y - halfHeight,
        local.pos.z - radius
    );
    const playerMax = new THREE.Vector3(
        local.pos.x + radius,
        local.pos.y + halfHeight,
        local.pos.z + radius
    );

    local.onGround = false;

    let horizAdjust = new THREE.Vector3();
    let horizCount = 0;

    // Track strongest floor and ceiling pushes
    let maxFloorY = -Infinity;
    let minCeilY = Infinity;
    let hitFloor = false;
    let hitCeil = false;

    blocks.forEach(b => {
        const min = b.position.clone().subScalar(0.5);
        const max = b.position.clone().addScalar(0.5);

        if (playerMax.x > min.x && playerMin.x < max.x &&
            playerMax.y > min.y && playerMin.y < max.y &&
            playerMax.z > min.z && playerMin.z < max.z) {

            const overlapX = Math.min(playerMax.x - min.x, max.x - playerMin.x);
            const overlapY = Math.min(playerMax.y - min.y, max.y - playerMin.y);
            const overlapZ = Math.min(playerMax.z - min.z, max.z - playerMin.z);

            const minOverlap = Math.min(overlapX, overlapY, overlapZ);

            if (minOverlap === overlapY) {
                if (local.vel.y <= 0 && (playerMin.y < max.y)) {
                    // touching floor: track the HIGHEST floor
                    maxFloorY = Math.max(maxFloorY, max.y + halfHeight);
                    hitFloor = true;
                } else if (local.vel.y > 0) {
                    // hitting ceiling: track the LOWEST ceiling
                    minCeilY = Math.min(minCeilY, min.y - halfHeight);
                    hitCeil = true;
                }
            } else if (minOverlap === overlapX) {
                let adjustX = (local.pos.x < b.position.x) ? -overlapX : overlapX;
                horizAdjust.x += adjustX;
                horizCount++;
            } else {
                let adjustZ = (local.pos.z < b.position.z) ? -overlapZ : overlapZ;
                horizAdjust.z += adjustZ;
                horizCount++;
            }
        }
    });

    // Apply strongest floor
    if (hitFloor) {
        local.pos.y = maxFloorY;
        local.vel.y = 0;
        local.onGround = true;
    }

    // Apply strongest ceiling
    if (hitCeil) {
        local.pos.y = minCeilY;
        local.vel.y = 0;
    }

    // Apply averaged horizontal adjustment
    if (horizCount > 0) {
        horizAdjust.divideScalar(horizCount);
        local.pos.add(horizAdjust);
    }

    // Jump
    if (local.onGround && keys['Space']) local.vel.y = 12;

    // Animation & mesh
    const moveLen = move.length();
    if (moveLen > 0) {
        const targetYaw = Math.atan2(move.x, move.z);
        local.yaw += (targetYaw - local.yaw) * 0.2;
        local.walkTime += dt * 6;
        const swing = Math.sin(local.walkTime) * 0.5;
        local.mesh.shoulderL.rotation.x = swing;
        local.mesh.shoulderR.rotation.x = -swing;
        local.mesh.hipL.rotation.x = -swing;
        local.mesh.hipR.rotation.x = swing;
    } else local.walkTime = 0;

    const meshHeight = 2.2;
    local.mesh.group.position.set(
        local.pos.x,
        local.pos.y - (playerHeight / 2) + (meshHeight / 2) - .1,
        local.pos.z
    );
    local.mesh.group.rotation.y = local.yaw;

    // Camera
    const camTarget = local.pos.clone().add(new THREE.Vector3(0, 1.2, 0));
    const dir = new THREE.Vector3(
        Math.sin(local.cam.yaw) * Math.cos(local.cam.pitch),
        Math.sin(local.cam.pitch),
        Math.cos(local.cam.yaw) * Math.cos(local.cam.pitch)
    );
    camera.position.copy(camTarget.clone().addScaledVector(dir, local.cam.dist));
    camera.lookAt(camTarget);

    socket.emit('move', { x: local.pos.x, y: local.pos.y, z: local.pos.z, yaw: local.yaw, name: local.name });
}
function updatePreviewBlock() {
    if (!activeTool) {
        previewBlock.visible = false;
        return;
    }

    // Raycast from camera through mouse
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(blocks);

    if (hits.length > 0) {
        const hit = hits[0];
        let pos = hit.point.clone();

        if (activeTool === 'build') {
            pos.add(hit.face.normal.clone().multiplyScalar(0.5));
            previewBlock.material.color.set(0x00ff00); // green
        } else if (activeTool === 'remove') {
            pos = hit.object.position.clone(); // center of the block
            previewBlock.material.color.set(0xff0000); // red
        }

        // Snap to grid
        previewBlock.position.set(
            Math.floor(pos.x) + 0.5,
            Math.floor(pos.y) + 0.5,
            Math.floor(pos.z) + 0.5
        );

        previewBlock.visible = true;
    } else {
        previewBlock.visible = false;
    }
}

function animateOthers(dt){
  others.forEach(p=>{
    const move=new THREE.Vector3().subVectors(p.pos,p.group.position);
    if(move.length()>0.01){ p.group.position.lerp(p.pos,0.2); const targetYaw=Math.atan2(move.x,move.z); p.group.rotation.y+=((targetYaw-p.group.rotation.y)*0.2);
      p.walkTime+=(dt*6); const swing=Math.sin(p.walkTime)*0.5;
      p.shoulderL.rotation.x=swing; p.shoulderR.rotation.x=-swing; p.hipL.rotation.x=-swing; p.hipR.rotation.x=swing;
    } else p.walkTime=0;
    p.nametag.sprite.quaternion.copy(camera.quaternion);
  });
}

let last = performance.now();

function animate(now) {
    requestAnimationFrame(animate);

    const dt = (now - last) / 1000;
    last = now;

    // Step physics and movement
    step(dt);

    // Animate other players
    animateOthers(dt);

    // Update the preview block (green highlighted block)
    updatePreviewBlock();

    const healthPercent = Math.max(0, Math.min(100, local.health));
    document.getElementById('healthBar').style.width = healthPercent + '%';

    // Render the scene
    renderer.render(scene, camera);
}

// Start the animation loop
animate(last);

window.addEventListener('resize',()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); });
</script>
</body>
</html>



